
---
title: 'Projet - ACP sur des Eaux '
author: "Solène Catella, Hugo Le Baher"
date: "23 novembre 2018"
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


##Sommaire

[Introduction]

[1. Analyse univariée et bivariée]

[1.1 Etude du jeu de données]

[1.2 Analyse exloratoire des données]

[1.2.1 Recherche des données manquantes]

[1.2.2 Analyse unidimensionnelle : variables qualitatives]

[1.2.3 Analyse unidimensionnelle : variables quantitatives]

[1.2.4 Recherche des valeurs extrêmes/outliers]

[1.2.5 Analyse bidimensionnelle]

[2. Analyse multivariée]

[2.1 ACP sur le premier jeu de données]

[2.1.1 Sélection des axes et plans retenus]

[2.1.2 Projection des variables et observations dans un plan donné]

[2.1.3 Analyse des observations supplémentaires]

[2.2 ACP sur le deuxième jeu de données]

[2.2.1 Sélection des axes et plans retenus]

[2.2.2 Projection des variables et observations dans un plan donné]

[2.3 ACP sur le troisième jeu de données]

[2.4 Classification non supervisée de type k-means]

## Introduction

<div style="text-align:justify">
Gazeuse, dé-ionisée ou encore riche en magnésium, l'eau, élément naturel et central dans notre vie quotidienne, peut revêtir plusieurs formes. Sa composition minérale, sa provenance, sa nature mais aussi son potentiel hydrogène sont autant de paramètres qui entrent en jeu dans sa caractérisation. Analyser une eau revient donc à s'intéresser à l'ensemble des attributs et propriétés susceptibles de la définir.

Le jeu de données dont nous disposons recense près de 100 eaux (95 exactement), déclinées sous 12 variables à la fois qualitatives (nom, nature, pays) et quantitatives (composition ionique, sodique, etc.). L'intérêt d'une ACP est, entre autres, de caractériser des observations dites "multivariées", c'est-à-dire multidimensionnelles, et d'en dégager des relations de ressemblance/dissemblance. En d'autres termes, l'ACP permet d'avoir une vue globale et synthétique des données : c'est la raison pour laquelle son usage est ici parfaitement approprié. 

Avant de procéder à l'ACP en tant que telle, nous explorerons le jeu de données au travers d'analyses univariées et bivariées. Une classification de type non-supervisée sera menée en dernier lieu, via la méthode des K-means.

Le présent document a été réalisé à partir de RMarkdown.
</div>

## 1. Analyse univariée et bivariée
###1.1 Etude du jeu de données

`r waters <- read.table("./Eaux2018 FM.txt", header=TRUE, sep="\t")`

La commande `head` nous donne un premier aperçu du jeu de données étudié. Il s'agit de données relatives aux caractéristiques et propriétés minérales de diverses eaux.
```{r}
head(waters)
```

```{r}
dim(waters)
```
<div style="text-align:justify">
Le jeu de données comprend 95 observations réparties sur 12 variables, dont 3 catégorielles (Nom, Nature, Pays) et 9 numériques (Ca, Mg, Na, K, Cl, NO3, SO4, HCO3, PH).

Dans ce jeu de données, on distingue 84 observations actives (eaux françaises) pour 11 observations supplémentaires (eaux marocaines).

On note que certaines données sont incomplètes. En effet, toutes les variables ne sont pas renseignées pour chacune des différentes eaux. Par exemple, les concentrations en K, Cl et SO4 de l'eau <em>Aquarelle</em>, ainsi que son PH, ne sont pas connus (cf. tableau). Il convient dans un premier temps d'étudier la fiabilité des différentes variables, de façon à détecter les valeurs manquantes, incohérentes, extrêmes ou aberrantes : c’est l’objet des résumés unidimensionnels. 
</div>

### 1.2 Analyse exloratoire des données
####1.2.1 Recherche des données manquantes

On s'intéresse en premier lieu aux données manquantes, représentées via le symbole <em>NA</em>.

```{r}
colSums(is.na(waters))
```

<div style="text-align:justify">
Parmi les variables étudiées, on remarque que le NO3 et le PH sont celles qui enregistrent le plus grand nombre de valeurs manquantes (19 chacune), suivies des variables Cl, K, Nature, SO4 et HCO3. Ces données manquantes peuvent alors être : <br>

* Supprimées, de façon à ne conserver que les observations complètes ;
* Imputées par une valeur plausible ou aléatoire (méthodes d’imputation simples et multiples).

L’étude statistique unidimensionnelle peut nous aider à mieux appréhender la distribution des différentes variables, et préférer l’une ou l’autre de ces méthodes. Dans la mesure où l’Analyse en Composantes Principales (ACP) est une méthode appliquée à des variables quantitatives continues, nous nous intéresserons particulièrement à ces dernières, après avoir brièvement analysé les variables qualitatives.
</div>  
  
####1.2.2 Analyse unidimensionnelle : variables qualitatives

Le jeu de données comprend 3 variables qualitatives : le nom de l'eau (Nom), sa nature (Nature) et son origine (Pays).

```{r echo=FALSE}
cat.variables <- waters[sapply(waters, is.factor)]
```

Il peut ici être intéressant de s'intéresser aux propriétés minérales des eaux plates et gazeuses.

```{r echo=FALSE}
still.waters <- subset(waters, waters$Nature=='plat', select=Ca:PH)
gaz.waters <- subset(waters[sapply(waters, is.numeric)], waters$Nature=='gaz')
```
```{r}
summary(still.waters)
summary(gaz.waters)
```

<div style="text-align:justify">
Ces résumés nous indiquent que les eaux gazeuses sont en moyenne plus riches que les eaux plates tous minéraux confondus, à l'exception des nitrates (NO3) et sulfates (SO4). Les composants minéraux qui semblent être les plus discriminants dans la distinction des eaux plates et gazeuses sont le HCO3, le Na et le Ca (comparaison des médianes). On note également que les eaux gazeuses enregistrent un PH légèrement inférieur aux eaux plates. 

En termes de répartition des échantillons, on remarque que les eaux plates sont en quantité supérieure, représentant à peu près 2/3 du jeu de données. C'est le diagramme en mosaïque (mosaic plot) qui nous permet d'aboutir à de telles conclusions, en faisant la représentation des effectifs relatifs à un tableau de contingence, ici défini par les variables Pays et Nature. 

```{r fig.align='center', fig.cap="Figure 1"}
table(waters$Nature, waters$Pays) 
mosaicplot(~waters$Pays+waters$Nature, data=waters, main="Répartition des eaux par Pays et Nature", color=TRUE)
```

<br/>
Comme on peut le voir, les eaux gazeuses sont exclusivement françaises : il n'y a pas d'eaux marocaines gazeuses. On peut aussi relever que les eaux marocaines sont très peu représentées vis-à-vis des eaux françaises, raison pour laquelle elles sont sans doute traitées dans cette analyse comme des observations supplémentaires.<br/>
</div>

####1.2.3 Analyse unidimensionnelle : variables quantitatives

<div style="text-align:justify">
Nous nous intéressons désormais aux variables quantitatives.
 
La commande `summary` fournit un résumé détaillé des variables étudiées, ici numériques (minimum, premier quartile, médiane, moyenne, troisième quartile et maximum).
```{r}
summary(waters[sapply(waters, is.numeric)])
```

En moyenne, les eaux sont principalement concentrées en HCO3 (691.4 mg/L), Na (151.4 mg/L), Ca (111.1 mg/L) et SO4 (108.7 mg/L). Cependant, dans la mesure où un grand nombre de variables enregistrent des valeurs extrêmes telles HCO3 (maximum à 6722.2 mg/L) ou Na (maximum à 1945 mg/L), la médiane apparaît ici comme une meilleure mesure centrale, car plus robuste que la moyenne. Exception faites des variables HCO3 et Ca, on remarque que les concentrations oscillent alors entre 2 mg/L et 18 mg/L, tous composants minéraux confondus.
</div>

```{r echo=FALSE, fig.align='center', fig.cap="Figure 2"}
boxplot(waters[sapply(waters, is.numeric)])
```

<div style="text-align:justify">
<br/>Un examen plus fin, variable par variable, nous permettra de mieux apprécier leurs distributions respectives. On étudiera tout particulièrement les variables PH et NO3, enregistrant ici le plus grand nombre de données manquantes (19).
</div>

##### <br/><u>Etude de la variable PH</u>

<div style="text-align:justify">
Le tracé de la boîte à moustache de la variable PH laisse apparaître une distribution symétrique. On note que les valeurs de sa moyenne (6.905) et sa médiane (7.000) sont très proches. Sa distribution, homogène et faiblement dispersée, semble s’approcher de celle d’une loi Normale (voire figure ci-contre).
</div>

```{r echo=FALSE, fig.width=5, fig.height=5, fig.show='hold', out.width="49%"}
boxplot(waters$PH, main="Boîte à moustache de la variable PH")
hist(waters$PH, prob=TRUE, main="Histogramme et densité de probabilité du PH", xlab="PH")
curve(dnorm(x, mean=mean(waters$PH, na.rm=TRUE), sd=sd(waters$PH, na.rm=TRUE)), add=TRUE, col="red")
```

<div style="text-align:center">Figure 3</div>


<div style="text-align:justify">
<br/>L'histogramme du PH, approché par une courbe de densité en forme de "cloche", vient confirmer cette hypothèse (voir figure ci-contre).
</div>

##### <br/><u>Etude de la variable NO3</u>

La distribution de la variable NO3 est ici quelque peu différente : l’histogramme indique une distribution non-symétrique et non-homogène.

```{r echo=FALSE, fig.width=5, fig.height=5, fig.show='hold', out.width="49%"}
boxplot(waters$NO3, main="Boîte à moustache de la variable NO3")
hist(waters$NO3, prob=TRUE, main="Histogramme et densité de probabilité du NO3", xlab="NO3")
curve(dnorm(x, mean=mean(waters$NO3, na.rm=TRUE), sd=sd(waters$NO3, na.rm=TRUE)), add=TRUE, col="red")
```

<div style="text-align:center">Figure 4</div>

<div style="text-align:justify">
<br/>Le tracé de la boîte à moustache de cette variable révèle la présence de nombreuses valeurs extrêmes (symbolisées par un “°”) : ces valeurs s'écartent fortement de la valeur moyenne obtenue. 
</div>

##### <br/><u>Etude des variables Cl, K, SO4 et HCO3 :</u>

<div style="text-align:justify">
Les variables Cl, K, SO4 et HCO3 témoignent d’une distribution à nouveau non symétrique, peu homogène, enregistrant un grand nombre de valeurs extrêmes. Le tracé de leur densité de probabilité s’éloigne ici d’une loi normale. 

```{r echo=FALSE, fig.height=8, fig.width=10, out.width="100%", fig.align='center', fig.cap="Figure 5"}
par(mfrow=c(2,2))
hist(waters$Cl, prob=TRUE, main="Histogramme et densité de probabilité du Cl", xlab="Cl")
curve(dnorm(x, mean=mean(waters$Cl, na.rm=TRUE), sd=sd(waters$Cl, na.rm=TRUE)), add=TRUE, col="red")
hist(waters$K, prob=TRUE, main="Histogramme et densité de probabilité du K", xlab="K")
curve(dnorm(x, mean=mean(waters$K, na.rm=TRUE), sd=sd(waters$K, na.rm=TRUE)), add=TRUE, col="red")
hist(waters$SO4, prob=TRUE, main="Histogramme et densité de probabilité du SO4", xlab="SO4")
curve(dnorm(x, mean=mean(waters$SO4, na.rm=TRUE), sd=sd(waters$SO4, na.rm=TRUE)), add=TRUE, col="red")
hist(waters$HCO3, prob=TRUE, main="Histogramme et densité de probabilité du HCO3", xlab="HCO3")
curve(dnorm(x, mean=mean(waters$HCO3, na.rm=TRUE), sd=sd(waters$HCO3, na.rm=TRUE)), add=TRUE, col="red")
```

<br/>Avant de poursuivre notre analyse par une étude bidimensionnelle, il peut donc être pertinent de s’intéresser aux données suspectes (outliers) susceptibles d’être à l’origine de ces distorsions, afin de les corriger et/ou supprimer puisqu’elles influeront nécessairement sur les résultats obtenus dans le cadre de notre ACP.
</div>


####1.2.4 Recherche des valeurs extrêmes/outliers

<div style="text-align:justify">
Le repérage des données suspectes peut être mené via plusieurs méthodes. Le test de Grubbs est le test le plus courant, mais n’étant applicable que si la distribution de l’échantillon suit une loi Normale ou est voisine d'une loi Normale, il ne sera ici pas retenu.

Graphiquement, le tracé des boxplots révèle la présence d’outliers pour les variables SO4, K, Na, Cl et HCO3, et dans une moindre mesure NO3, Ca et Mg. Dans le cadre de variables continues, il s’agit des observations dont la valeur excède 1.5 fois l’écart interquartile. La commande `boxplot.stats(data)$out` permet de dégager ces valeurs, en considérant chaque variable prise une à une (par exemple ici, SO4) :

</div>

```{r}
boxplot.stats(waters$SO4)$out
```

La commande which permet d’identifier les indices des outliers :

```{r}
which(waters$SO4 %in% boxplot.stats(waters$SO4)$out)
```
  
<div style="text-align:justify">
Les outliers sont donc très présents dans ce jeu de données. Il pourrait ainsi être judicieux de générer un deuxième jeu de données sans ces extrema, ou en tout cas essayer de s'en affranchir autant que faire se peut, de façon à ne pas biaiser la suite de notre étude. Passer ces données en observations supplémentaires dans le cadre de notre ACP est une façon de neutraliser ces valeurs.
</div>

 
####1.2.5 Analyse bidimensionnelle

<div style="text-align:justify">
Intéressons-nous désormais à l'analyse bidimensionnelle. L’objectif ici est de pouvoir mettre en évidence, pour chaque paire de variables considérée, l’existence de variations simultanées, aussi appelées liaisons. 
La matrice des scatterplots permet de visualiser les liaisons existantes entre variables quantitatives prises deux à deux. 
</div>

```{r, fig.align='center', fig.cap="Figure 6"}
plot(waters[sapply(waters, is.numeric)])
```

<div style="text-align:justify">
<br/>On observe ainsi graphiquement l’existence de corrélations entre les variables Na, K et HCO3. Cette hypothèse peut être vérifiée via l’étude numérique des corrélations inter-variables (`commande cor`).
</div>

```{r, fig.align='center'}
round(cor(waters[sapply(waters, is.numeric)], use="complete.obs"),3)
```

<div style="text-align:justify">

Les variables les plus corrélées positivement sont les variables HCO3 et NA (0.910), Na et K (0.867) et HCO3 et K (0.883) : elles varient simultanément de façon semblable.  
  
On remarque que le PH est corrélé négativement à toutes les autres variables, exception faite du composant S04. Le comportement de cette variable est donc, de façon générale, opposé à celui des autres variables.  
  
Il faut cependant rester vigilant quant aux résultats obtenus. En effet, la présence de valeurs extrêmes peut venir perturber notre analyse, ici portée sur l’étude des corrélations. En effet, le coefficient de corrélation de Pearson (méthode par défaut) est très sensible aux valeurs de données extrêmes. Il peut donc être intéressant de réitérer cette analyse sans prendre en compte cette fois-ci les données extrêmes/outliers enregistrés, soit en les supprimant, soit en transformant les variables pour rendre plus symétriques et moins étalées certaines distributions (en prenant les logarithmes par exemple). Nous mettrons en oeuvre ici la première option :

```{r echo=FALSE}
library(plotrix)
library(ade4)

acpn = function(data_in, round_precision = 3){  
  result = list()
  
  result$source = data_in
  #Filtre
  result$raw_data = na.omit(data_in[sapply(data_in, is.numeric)])
  result$matrix = as.matrix(result$raw_data, rownames.force = NA)
  
  #Retour
  return(result)
}
waters <- read.table("./Eaux2018 FM.txt", header=TRUE, sep="\t")
active.waters <- waters[waters$Pays %in% "France",] 
supp.waters <- waters[waters$Pays %in% "Maroc",] 
acp_waters = acpn(active.waters)
round(cor(acp_waters$matrix[setdiff(c(1:nrow(acp_waters$matrix)), unique(unlist(apply(acp_waters$matrix, 2, function(x){which(x %in% boxplot.stats(x)$out)})))),]),3)
```

L'élimination des outliers du jeu de données laisse apparaître de nouvelles corrélations, en particulier au niveau de la variable HCO3, désormais très corrélée aux variables Mg, Na et SO4 - elles-mêmes très corrélées entre elles. Il pourra donc être intéressant d'étudier ce groupe de variables dans le cadre de notre troisième ACP, où nous passerons les différents extrema recensés en observations supplémentaires. L'idée sera alors de comparer, d'une ACP à l'autre, les groupes de variables formés et la nature des axes en découlant. 
</div>

##2. Analyse multivariée

<div style="text-align:justify">
Trois jeux de données seront ici considérés :

* un premier jeu de données diminué des données manquantes (approche simpliste) ;
* un deuxième jeu de données où l’ensemble des données manquantes seront substituées par des valeurs approximatives, et ce afin de conserver le maximum d’information possible ;
* un troisième jeu de données brute où, comme nous l'avons écrit plus haut, les outliers seront passés en observations supplémentaires.

Il s’agira donc de travailler sur les données brutes d’abord (1), puis sur un jeu de données transformé ensuite (2). Dans la mesure où les résultats d’une ACP peuvent être biaisés par la présence de données suspectes et que celles-ci sont ici nombreuses, une troisième ACP, où seront passées en individus supplémentaires l’ensemble des données suspectes, sera réalisée. À noter qu’il aurait également été envisageable de neutraliser ces données à l’aide d’une ACP sur les rangs, plus robuste qu’une ACP classique.
</div>

###2.1 ACP sur le premier jeu de données

<div style="text-align:justify">
Nous considérons ici le jeu de données brutes, diminué des données manquantes. <br/>
La commande `na.omit` permet d’éliminer d’un jeu de données toutes les lignes incomplètes (contenant des valeurs “NA”).

```{r}
complete.waters <- na.omit(waters)
dim(complete.waters)
```

On note que 33 observations ont ainsi été retirés du jeu de données initial.

De plus, dans la mesure où l’on souhaite ici que les eaux marocaines soient traitées comme des observations supplémentaires et non pas actives, il faut veiller à les retirer au préalable. Une fois ce traitement réalisé, le jeu de données à traiter ne comporte alors plus que 55 lignes.

Avant de débuter l’ACP à proprement parler, il convient de faire un choix de métrique. Dans la mesure où la variable PH ne s’exprime pas dans la même unité que les autres variables (concentrations en mg/L), on préfèrera ici mettre en oeuvre une ACP normée (ACPN). Éliminer la variable PH du jeu de données conduirait en effet à une perte d’information non négligeable. De plus, les variances des variables étant très éloignées les unes des autres, une ACP non normée n'apparait pas judicieuse.<br/>
</div>

####2.1.1 Sélection des axes et plans retenus

<div style="text-align:justify">
L’ACPN est effectuée par un appel à la procédure `dudi.pca`.

La première étape consiste à sélectionner les axes à retenir. Cette sélection s’appuie sur l’examen des valeurs propres, où chaque valeur propre correspond à la part d’inertie projetée sur un axe donnée.

```{r echo=FALSE}
active.waters <- complete.waters[complete.waters$Pays %in% "France",] 
acp.variables <- active.waters[sapply(active.waters, is.numeric)] # On ne conserve que les obs. actives
library(ade4)
auto.acp <- dudi.pca(df = acp.variables, center = TRUE, scale = TRUE, scannf = FALSE, nf = 9)
```

Dans le cadre d’une ACP normée, on peut utiliser le critère de Kaiser selon lequel ne seront retenus que les facteurs ayant une valeur propre supérieure à 1. On remarque ici que seules les trois premières valeurs propres sont supérieures à 1. L’histogramme des valeurs propres traduit ce fait.
</div>

```{r}
round(cumsum(100*auto.acp$eig/sum(auto.acp$eig)), 3)
```
Cumulées, elles représentent alors plus de 82.02% de la variabilité totale. On ne conservera donc ici que les trois premiers axes.
<br/>  

####2.1.2 Projection des variables et observations dans un plan donné
  
#####<u>Analyse des variables</u>

```{r}
round(auto.acp$co,3)
```

<div style="text-align:justify">
On remarque que :

* La première composante traduit l’existence de fortes corrélations entre HCO3 (-0.917), K (-0.907), Na (-0.864) et Mg (-0.792), comme évoqué un peu plus haut.
* La deuxième composante traduit l’existence de fortes corrélations entre Ca (-0.886) et SO4 (-0.944).
* Enfin, la troisième composante traduit l’existence de corrélations négatives entre NO3 (-0.903) et PH (0.554)

NB : On note que la variabilité des six dernières composantes principales (non retenues ici) est beaucoup plus faible que celle des composantes retenues. Autrement dit, la distance qu’elles traduisent entre les observations est négligeable.<br/>

Le tracé du cercle des corrélations peut nous aider à apprécier ces corrélations, ainsi que la bonne représentation des différentes variables (proximité vis-à-vis du bord du cercle). Dans la mesure où l’on a décidé ici de retenir 3 axes, il faut alors tracer trois graphiques distincts pour chaque nuage : le nuage projeté sur le plan (axe1, axe2), celui projeté sur le plan (axe1, axe3) et enfin celui sur le plan (axe2, axe3).  
</div>

```{r echo=FALSE, out.width='49%'}
s.corcircle(auto.acp$co, xax=1, yax=2); mtext("Cercle des corrélations dans le plan 1-2")
s.corcircle(auto.acp$co, xax=1, yax=3); mtext("Cercle des corrélations dans le plan 1-3")
s.corcircle(auto.acp$co, xax=2, yax=3); mtext("Cercle des corrélations dans le plan 2-3")
```

<div style="text-align:center">Figure 7</div>

<div style="text-align:justify">
<br/>Le premier plan principal permet de distinguer 2 groupes de variables distincts, tels que décrits plus haut : Na, K, HCO3 et Cl d’une part, Mg, Ca et SO4 d’autre part. Les variables NO3 et PH sont assez mal représentées dans ce plan (éloignées du bord du cercle de corrélation), à la différence des plans 1-3 et 2-3 où leur représentation est bonne. L’existence de corrélations négatives entre ces deux variables est facilement visualisable dans ces configurations. La conservation des trois premiers axes est donc ici nécessaire si l’on ne souhaite pas aboutir à de mauvaises interprétations.

<u>Interprétation des axes :</u>

* Axe 1 : cet axe est lié aux concentrations en Na, K, Cl et HCO3. Il caractérise la teneur sodique des eaux (riches en sodium ou non) ;
* Axe 2 : cet axe est lié aux concentrations en Ca, Mg et SO4. Il caractérise la teneur minérale des eaux (fortement minéralisées ou non) ;
* Axe 3 : cet axe est lié aux concentrations en NO3. Il caractérise le pouvoir nitrique des eaux (acides ou non).

L'analyse des répartition des observations par nature (eaux plates ou gazeuses) dans chacun des plans permettra de mettre en confrontation les variables quantitatives ici présentées avec la variable qualitative Nature (cf. "Analyse croisée des variables et observations").
</div>

##### <br/><u>Analyse des observations</u>
<div style="text-align:justify">

```{r echo=FALSE}
obs.inertie <- inertia.dudi(auto.acp, row.inertia=TRUE)
obs.ctr <- obs.inertie$row.abs/100 # (Contribution des observations en %)
obs.qlt <- obs.inertie$row.re/100 # (Qualité des observations en %)
```

<u>Qualité de représentation des observations :</u>

La commande `obs.inertie$row.re` permet d’apprécier la qualité de représentation des différents individus sur les différents axes.
La qualité de représentation d’un individu dans un plan donné s’évalue en sommant les qualités de représentation de ce même individu sur les axes du plan donné. Sont affichées ici les 30 premières qualités. 

NB : Il faut se reporter au jeu de données initial pour établir la correspondance entre un échantillon (numéro) et l'eau associée.

```{r}
head(round(obs.qlt[,1:3],3),30)
```

<B>Plan 1-2 :</B>
les individus les mieux représentés dans le plan 1-2 sont les eaux Contrex (99,06%), Hepar (98,82%), Courmayeur (95,46%), Talians (95,32%), Christalline Aurelie (92,61%), Zilia (92,14%) et Arvie (90,36%). Les individus les moins bien représentés dans le plan 1-2 sont les eaux Perrier (1,97%), Salvetat (2,55%) et Christalline St Sophie (6,99%)

<B>Plan 1-3 : </B>
les individus les mieux représentés dans le plan 1-3 sont les eaux Perrier (94,54%), Montagne Ecrins (92,38%), Montagne Alpes (92,37%) et Christalline Aurelie  (92,11%). Les individus les moins bien représentés dans le plan 1-3 sont les eaux Contrex (0,88%), Courmayeur (1,23%), Talians (2,45%), Hepar (2,60%) et Salvetat (5,92%)

<B>Plan 2-3 :</B>
les individus les mieux représentés dans le plan 2-3 sont les eaux Contrex (98,18%), Courmayeur (96,65%), Talians (96,51%), 44 (96,22%) et Perrier (92,85%). Les individus les moins bien représentés dans le plan 2-3 sont les eaux Rozana (1,31%), Chateldon (3,36%), Christalline Aurelie (4,24%), Christalline St JB (4,86%) et Arvie (6,66%)

<u>Contribution des observations aux axes :</u>

Nous nous intéressons ici aux observations dont la contribution est supérieure à la contribution moyenne par axe.
Voici un extrait des contributions des observations aux axes 1, 2 et 3.

```{r}
head(round(obs.ctr[,1:3],3),40)
```

Les eaux Arvie (échantillon 10), Rozana (échantillon 63), Parot (échantillon 57) et Vichy Celestins (échantillon 78) enregistrent les valeurs (absolues) de la première composante les plus élevées. Ces eaux sont naturellement riches en Na, K, Cl et HCO3, plutôt acides (PH < 7) et gazeuses.<br/>

Un examen identique de la seconde composante révèle que les eaux Talians (échantillon 72), Hepar (échantillon 44), Courmayeur (échantillon 20) et Contrex (échantillon 19) ont des valeurs très supérieures à la moyenne sur cette composante. Ces eaux sont naturellement riches en Ca, Mg et SO4, plutôt basiques ou alcalines (PH > 7) et plates.<br/>

Enfin, les eaux Perrier (échantillon 58), Thonon (échantillon 74), Ste Marguerite (échantillon 68) et Badoit (échantillon 12) enregistrent les valeurs les plus élevées de la troisième composante. Ces eaux ont la particularité d’être fortement concentrées en NO3.<br/>

L’ACP a donc permis de mettre en évidence des groupements de propriétés minérales propres à certains types d’eaux, difficilement perceptible au premier coup d’oeil.<br/>

En résumé, la contribution des individus aux différents axes (par ordre décroissant de contribution) est la suivante :

Axe 1 : Arvie, Rozana, Parot, Vichy Celestins
 
Axe 2 : Talians, Hepar, Courmayeur, Contrex
 
Axe 3 :  Perrier, Thonon, Ste Marguerite, Badoit

##### <br/><u>Analyse croisée des variables et observations</u>

Le tracé des graphiques de répartion des eaux par Nature (plates, gazeuses) dans les différents plans considérés est présenté ci-contre. Il permet notamment de mettre en relation les variables quantitatives précédemment étudiées avec la variable qualitative Nature, en considérant les individus bien représentés seulement. 

En rouge, sont désignées les observations de nature gazeuse; en noir, les observations de nature plate. 
Les cercles de corrélations ici dessinés sont ceux issus de notre fonction ACP.

```{r echo=FALSE, out.width='49%'}
acpn = function(data_in, round_precision = 3){  
  result = list()
  
  result$source = data_in
  #Filtre
  result$raw_data = na.omit(data_in[sapply(data_in, is.numeric)])
  result$matrix = as.matrix(result$raw_data, rownames.force = NA)
  num_row = nrow(result$raw_data)
  num_col = ncol(result$raw_data)
  
  #Moyenne
  result$mean = apply(result$matrix, 2, mean)
  result$meanmatrix = t(matrix( rep(x=result$mean, num_row), nrow = num_col, byrow = FALSE))

  #Centrage avec scale
  result$autocen = scale(result$matrix, center = TRUE, scale = FALSE)
  #Centrage/Reduction avec scale
  result$autocenred = scale(result$matrix, center = TRUE, scale = TRUE)

  #Centrage sans scale
  result$cen = result$matrix - result$meanmatrix

  #Variance/co-variance
  result$var = t(result$cen) %*% result$cen / (num_row - 1)
    
  #Centrage/Reduction sans scale
  result$stddev = diag(sapply(diag(as.matrix(result$var)), function(x){1/sqrt(x)}))
  result$cenred = result$cen %*% result$stddev
  
  #Correlation
  result$cor = t(result$cenred) %*% result$cenred / (num_row - 1)
  
  #Valeurs propres
  eigen_full = eigen(result$cor)
  result$eigen$values = eigen_full$values[eigen_full$values>1.0]
  result$eigen$vectors = eigen_full$vectors[,1:length(result$eigen$values)]
  
  #Composantes principales
  result$comp = result$cenred %*% result$eigen$vectors
  
  #Rapport de l'inertie
  result$inertiaratio = result$eigen$values / num_col
  
  #Inertie cumulée
  result$inertiasum = round(sum(result$inertiaratio),3)*100

  #Contribution relative des individus
  result$qlti = (result$comp)^2
  for (i in 1:nrow(result$qlti)) {
    for (k in 1:ncol(result$qlti)) {
      result$qlti[i,k] = result$qlti[i,k] / (sum(result$comp[i,]^2))
    }
  }
  result$qtli = round(result$qlti, round_precision)
  
  #Contribution absolue des individus
  result$ctri = (result$comp)^2
  for (i in 1:nrow(result$ctri)) {
    for (k in 1:ncol(result$ctri)) {
      result$ctri[i,k] = result$ctri[i,k] / (ncol(result$ctri)*result$eigen$values[k])
    }
  }
  result$ctri = round(result$ctri, round_precision)
  
  #Matrice des coordonnées de variables
  D = diag(sapply(as.matrix(result$eigen$values), sqrt))
  result$coords = result$eigen$vectors %*% D
  
  #Contribution relative des variables
  result$qltv = (result$coords)^2
  for (j in 1:nrow(result$qltv)) {
    for (k in 1:ncol(result$qltv)) {
      result$qltv[j,k] = result$qltv[j,k] / (sum(result$coords[j,]^2))
    }
  }
  result$qtlv = round(result$qltv, round_precision)
  
  #Contribution absolue des variables
  result$ctri = (result$comp)^2
  for (i in 1:nrow(result$ctri)) {
    for (k in 1:ncol(result$ctri)) {
      result$ctri[i,k] = result$ctri[i,k] / (ncol(result$ctri)*result$eigen$values[k])
    }
  }
  result$ctri = round(result$ctri, round_precision)
  
  #Cercle de corrélation
  apply(combn(1:length(result$eigen$values), 2), 2, function(combi){
    axis1 = result$coords[,combi[1]]
    axis2 = result$coords[,combi[2]]
    par(mfrow=c(1,1))
    plot(axis1, axis2, xlim=c(-1,1), ylim=c(-1,1), asp = 1, type = "n", xlab = sprintf("Axe %d",combi[1]), ylab = sprintf("Axe %d",combi[2]), main = sprintf("Cercle des corrélations dans le plan %d-%d", combi[1], combi[2]) )
    abline(h=0,v=0)
    draw.circle(x = 0, y = 0, radius = c(1,1))
    arrows(0, 0, axis1, axis2, length = 0.10, code = 2, col = gray(0.6))
    text(x=axis1, y=axis2, labels = colnames(result$raw_data), font=2) 
  })
  
  #Retour
  return(result)
}

waters <- read.table("./Eaux2018 FM.txt", header=TRUE, sep="\t")
active.waters <- waters[waters$Pays %in% "France",] 
supp.waters <- waters[waters$Pays %in% "Maroc",] 
acp_waters = acpn(active.waters)

water_type = c()
for(i in rownames(acp_waters$comp)){
  type = acp_waters$source$Nature[strtoi(i)]
  v = 0
  if(is.na(type)){}
  else if(type == "plat"){
    v=1
  }else if(type == "gaz"){
    v=2
  }
  water_type = c(water_type, v)
}

plot(main="Répartition des eaux par nature dans le plan 1-2", acp_waters$comp[,1], acp_waters$comp[,2], xlab = "Axe 1", ylab = "Axe 2", col=water_type)
legend(x = "bottomright",legend=unique(water_type),col=1:length(water_type),pch=1)

plot(main="Répartition des eaux par nature dans le plan 1-3", acp_waters$comp[,1], acp_waters$comp[,3], xlab = "Axe 1", ylab = "Axe 3", col=water_type)
legend(x = "bottomright",legend=unique(water_type),col=1:length(water_type),pch=1)

plot(main="Répartition des eaux par nature dans le plan 2-3", acp_waters$comp[,1], acp_waters$comp[,3], xlab = "Axe 2", ylab = "Axe 3", col=water_type)
legend(x = "bottomright",legend=unique(water_type),col=1:length(water_type),pch=1)

```

<div style="text-align:center">Figure 8</div>
<br/>
On remarque que c'est dans le plan 1-2 que la séparation entre eaux plates et gazeuses est la meilleure. Or, nous avons précédemment déduit que l'axe 1 était associé aux concentrations en Na, K, Cl et HCO3 d'une part, et que les composants minéraux qui semblaient être les plus discriminants dans la distinction des eaux plates et gazeuses étaient le HCO3 et le Na d'autre part. L'analyse graphique est donc concordante avec les résultats de notre analyse.
</div>

####2.1.3 Analyse des observations supplémentaires

<div style="text-align:justify">
Les observations supplémentaires sont des eaux provenant du Maroc, exclusivement plates. Comparativement aux eaux françaises, les eaux marocaines sont plus riches en Na.

```{r echo=FALSE}
supp.waters <- waters[waters$Pays %in% "Maroc",] 
supp.waters
summary(supp.waters)
```

Parmi ces 11 observations supplémentaires, 4 enregistrent des valeurs manquantes, notamment au niveau de leur PH. Dans la mesure où nous avons précédemment vu que la distribution du PH s’apparente à celle d’une loi normale, on peut raisonnablement substituer ces valeurs manquantes par la valeur médiane de cette variable, qui vaut ici 7.0. Cela évite ainsi d’éliminer un tiers des observations supplémentaires.<br/>

Etant donné que nous n’avons pas réalisé d’estimation pour les données manquantes enregistrées au niveau de la variable Cl (cf. deuxième jeu de données), nous avons ici pris le parti de supprimer l’observation Ain Soltane (échantillon 89).
Ces individus supplémentaires (ici en rouge) ont été représentés dans chacun des plans 1-2, 1-3 et 2-3.

Les cercles de corrélations ont été ici ajoutés une nouvelle fois de façon à plus facilement superposer les résultats d'analyse.
</div>

```{r echo=FALSE}
new.supp.waters <- na.omit(supp.waters)
axe1 <- auto.acp$li[,1]
axe2 <- auto.acp$li[,2]
axe3 <- auto.acp$li[,3]
```

La qualité de représentation des individus supplémentaires s'obtient à partir des commandes suivantes :

```{r}
ligsup <- suprow(auto.acp,new.supp.waters[3:11])
acpcos2sup <- ligsup$lisup^2/apply(ligsup$lisup^2, 1, sum)
round(acpcos2sup[,1:3]*1000)
```
<div style="text-align:justify">
Seules les observations bien représentées peuvent être correctement analysées. L'observation #86 est, à titre d'exemple, très mal représentée, quel que soit le plan. Même chose pour l'observation #94 dans le plan 1-3. Nous nous focaliserons donc sur les autres observations.

```{r echo=FALSE, out.width="49%"}
csup1 <- ligsup$lisup[,1]
csup2 <- ligsup$lisup[,2]
plot(axe1, axe2, type="n", main="Individus actifs et supplémentaires dans le plan 1-2", xlim=c(-2,2))
abline(h=0,v=0)
text(axe1, axe2, row.names(auto.acp$li),)
text(csup1, csup2, row.names(ligsup$lisup), col="red", cex=1.2)
# Graphe des observations actives et supplémentaires - plan 1-3
csup3 <- ligsup$lisup[,3]
plot(axe1, axe3, type="n", main="Individus actifs et supplémentaires dans le plan 1-3", xlim=c(-2,2))
abline(h=0,v=0)
text(axe1, axe3, row.names(auto.acp$li),)
text(csup1, csup3, row.names(ligsup$lisup), col="red", cex=1.2)
# Graphe des observations actives et supplémentaires - plan 2-3
plot(axe2, axe3, type="n", main="Individus actifs et supplémentaires dans le plan 2-3", xlim=c(-2,2))
abline(h=0,v=0)
text(axe2, axe3, row.names(auto.acp$li),)
text(csup2, csup3, row.names(ligsup$lisup), col="red", cex=1.2)
```
```{r echo=FALSE, out.width='49%'}
s.corcircle(auto.acp$co, xax=1, yax=2); mtext("Cercle des corrélations dans le plan 1-2")
s.corcircle(auto.acp$co, xax=1, yax=3); mtext("Cercle des corrélations dans le plan 1-3")
s.corcircle(auto.acp$co, xax=2, yax=3); mtext("Cercle des corrélations dans le plan 2-3")
```
<div style="text-align:center">Figure 8</div>
<br/>

<U>Interprétation :</U>

On remarque que l'observation #88 (Oulmès) est une eau caractérisée par une forte concentration en HC03, Cl, K et Na. Cette eau se distingue des autres observations supplémentaires, isolée à la fois dans les plans 1-2 et 1-3. Si l'on jette un coup d'oeil au tableau d'analyse numérique inséré plus haut, on note en effet qu'elle enregistre des concentrations beaucoup plus importantes que les autres eaux pour les variables ici considérées.

Dans le plan 1-3, on distingue un groupe défini par les observations #95, #90, #91 et #87 : ces eaux sont comparativement plus concentrées en NO3 que les autres. 

Dans le plan 2-3, c'est l'eau <em>Ciel</em> (#94) qui se distingue, enregistrant de fortes concentrations en Na, K et Cl, ainsi que l'eau <em>Ain Saiss</em> (#87), qui enregistre la deuxième plus forte concentration en NO3.
</div>

##2.2 ACP sur le deuxième jeu de données

<div style="text-align:justify">
Nous considérons ici un deuxième jeu de données où les valeurs manquantes ne sont plus supprimées mais substituées/imputées par des valeurs approximatives.

Pour ce faire, on peut utiliser l’algorithme des k plus proches voisins, déjà implémenté au sein du package DMwR. Pour chaque valeur manquante, l’algorithme identifie les k observations les plus proches en terme de distance euclidienne et en calcule la moyenne pondérée.

La fonction `knnImputation` permet de générer un nouveau jeu de données suivant cette méthode. En voici un aperçu :

```{r echo=FALSE}
library(DMwR)
new.waters <- knnImputation(waters, k=10, scale=T, meth="weighAvg", distData=NULL) # On fixe k à 10 voisins
new.active.waters <- new.waters[new.waters$Pays %in% "France",]
head(new.active.waters)
acp.variables <- new.active.waters[sapply(new.active.waters, is.numeric)] # On ne conserve que les obs. actives
new.auto.acp <- dudi.pca(df = acp.variables, center = TRUE, scale = TRUE, scannf = FALSE, nf = 3)
```

On remarque par exemple que l'eau <em>Aquarelle</em>, originellement incomplète, a ici été imputée au niveau des variables K, Cl, SO4 et PH par les valeurs 1.01, 7.19, 20.67 et 7.12.

Nous pouvons désormais appliquer notre ACP sur ce nouveau jeu de données, en suivant la même méthode. 

####2.2.1 Sélection des axes et plans retenus

```{r}
round(new.auto.acp$eig,3)
round(cumsum(100*auto.acp$eig/sum(auto.acp$eig)), 3)
```

L'étude des valeurs propres selon le critère de Kaiser nous amène à conserver les trois premiers axes. L'inertie cumulée est sensiblement la même que celle obtenue dans le cadre de notre première ACP. 

####2.2.2 Projection des variables et observations dans un plan donné

#####<u>Analyse des variables</u>

```{r}
round(new.auto.acp$co,3)
```

On remarque que les corrélations entre variables sont ici identiques à celles précédemment établies. Le tracé du cercle des corrélations vient  confirmer la grande proximité des résultats obtenus dans ces deux ACP.

```{r echo=FALSE, out.width='49%'}
s.corcircle(new.auto.acp$co, xax=1, yax=2); mtext("Cercle des corrélations dans le plan 1-2")
s.corcircle(new.auto.acp$co, xax=1, yax=3); mtext("Cercle des corrélations dans le plan 1-3")
s.corcircle(new.auto.acp$co, xax=2, yax=3); mtext("Cercle des corrélations dans le plan 2-3")
```

L'interprétation des axes est donc par conséquent la même.

<div style="text-align:center">Figure 9</div>
<br/>

#####<u>Analyse des observations</u>

```{r echo=FALSE}
obs.inertie <- inertia.dudi(new.auto.acp, row.inertia=TRUE)
obs.ctr <- obs.inertie$row.abs/100 # (Contribution des observations en %)
obs.qlt <- obs.inertie$row.re/100
```

C'est l'analyse des observations qui va ici le plus nous importer. En effet, cette deuxième ACP va nous permettre de situer des observations qui, auparavant, avaient été éliminées du jeu de données. Là encore, il convient d'étudier la bonne qualité de représentation de ces observations. 

Pour en faciliter le repérage, la liste de ces observations est rappelée ci-contre :

```{r}
sort(unique(which(is.na(active.waters), arr.ind = TRUE)[,1]))
```

Les qualités sont résumées dans la table ci-contre :

```{r}
round(obs.qlt[4:13,1:3],3)
```

```{r echo=FALSE}
round(obs.qlt[30:50,1:3],3)
```
```{r echo=FALSE}
round(obs.qlt[76,1:3],3)
```

<B>Plan 1-2 :</B>
Parmi les individus imputés, les mieux représentés dans le plan 1-2 sont les eaux #4 (96,47%), #76 (94,44%), #45 (92,95%), #54 (92,07%), #35 (91,67%), #27 (91,30%). 

<B>Plan 1-3 : </B>
Parmi les individus imputés, les mieux représentés dans le plan 1-3 sont les eaux #46 (96,82%), #45 (92,69%), #76 (89,06%) et #39 (86,46%). À l'inverse, l'individu imputé #5 est assez mal représenté dans ce plan (2,85%).

<B>Plan 2-3 :</B>
Parmi les individus imputés, l'individu le mieux représenté dans le plan 2-3 est l'eau #13 (62,76%). Les individus imputés les moins bien représentés dans ce plan sont les eaux #45 (1,76%) et #43 (7,58%)

De façon générale, les individus qui étaient bien représentés dans la première ACP le sont aussi ici; même chose du côté des individus mal représentés.

<u>Contribution des observations aux axes :</u>

De la même façon, nous nous intéresserons ici aux observations dont la contribution est supérieure à la contribution moyenne par axe, en portant notre attention sur les observations imputées avant tout.

```{r}
round(obs.ctr[40:80,1:3],3)
```

Les eaux Hydroxydase (échantillon 45) et Vichy St Yorre (échantillon 79) enregistrent les valeurs (absolues) de la première composante les plus élevées, en plus des eaux précédemment identifiées lors de la première ACP. Ces eaux sont naturellement riches en Na, K, Cl et HCO3, plutôt acides (PH < 7) et gazeuses.

Un examen identique de la seconde composante ne révèle aucune indication supplémentaire. Les eaux imputées ne contribuent pas à cet axe. Même remarque pour le troisième axe.
</div>
##### <br/><u>Analyse croisée des variables et observations</u>
```{r echo=FALSE, out.width='49%'}
s.label(new.auto.acp$li,xax=1,yax=2); mtext("Projection des observations dans le plan 1-2") 
s.label(new.auto.acp$li,xax=1,yax=3); mtext("Projection des observations dans le plan 1-3") 
```
<br/>
```{r echo=FALSE, out.width='49%', fig.align="center"}
s.label(new.auto.acp$li,xax=2,yax=3); mtext("Projection des observations dans le plan 2-3") 
```

<div style="text-align:center">Figure 10</div>

<div style="text-align:justify">
<br/>L'idée ici est d'analyser les individus qui ont fait l'objet d'une imputation.

Comme on peut le voir dans le plan 1-2, l'eau Hydroxydase (échantillon 45) se distingue des autres échantillons de par ses fortes concentrations en Cl, HCO3, K et Na. C'est cette eau qui enregistre la plus haute composition en HCO3 (6722.2 mg/L). C'est un outlier pour cette variable. L'eau Vichy St Yorre (échantillon 79) enregistre également de fortes concentrations pour ces variables, même si, dans une moindre mesure. Ces deux échantillons se distinguent facilement sur le premier graphique.

L'interprétation liée aux projections des individus imputés sur les autres plans ne pourra pas être aussi concluante, dans la mesure où leur qualité de représentation n'est pas (ou moins) significative, exception faite de l'échantillon 45. 

Cette étude s'est donc avérée enrichissante, dans la mesure où elle a permis de repositionner quelques individus préalablement non étudiés, bien que la qualité de représentation de la majorité d'entre eux, trop médiocre, a limité la portée de notre analyse.
</div>
##2.4 Classification non supervisée de type k-means

<div style="text-align:justify">
Pour approfondir notre analyse, on peut choisir de classer nos individus par catégories, par classes. Ainsi, on pourrait voir apparaître différents types d'eau dans nos données.  
  
Plusieurs méthodes s'offrent à nous. Cependant, nous n'avons pas vraiment de types d'eaux prédéfinis, ni de données d'entraînement sur lesquelles on pourrait s'appuyer : le choix d'une méthode de partitionnement non supervisée semble donc raisonnable.  
  
La fonction kmeans(data, k) déjà implémentée remplit ce rôle de manière satisfaisante. À partir des données d'entrée et d'un nombre de classes k, l'algorithme va alors regrouper les individus selon les distances des uns par rapport aux autres, jusqu'à trouver les distances minimales.
  
Même si l'algorithme est déjà implémenté, il nous faut quand même trouver un k optimal. En effet, ce choix est primordial. Si on prend un k trop petit, le risque est de se retrouver avec des classes peu représentatives, assez arbitraires. Cependant, si le k choisi est trop grand, on peut obtenir des classes qui ne s'appliquent qu'à notre jeu de données, ou alors avoir beaucoup de classes mais avec très peu d'individus.  
  
Un nombre classique de classes est $\sqrt{2/n}$, notre n étant le nombre d'individus (c'est-à-dire 63 après avoir filtré les données); un k optimal s'approcherait de 6. On va confirmer cette hypothèse avec la méthode suivante :  
  
Quand on applique l'algorithme, il nous renvoie la somme des carrées des distances entre les individus et le centre des classes. Une part plus petite par rapport à la somme de toutes les distances étant meilleure, on peut dessiner le graphique de cette part, en fonction de k. En observant les décrochages de la courbe, on peut alors décider d'un k satisfaisant.  
  
Il faut aussi préciser que la fonction kmeans incorpore de l'aléatoire, on préfère donc fixer la graine de l'aléatoire afin d'avoir toujours les mêmes résultats.

L'algorithme nous revoie donc un tableau des individus avec un numéros de classe associé. On peut alors, pour se donner une idée, appliquer ce tableau à une représentation en deux ou trois dimensions issue de l'ACP.

</div>