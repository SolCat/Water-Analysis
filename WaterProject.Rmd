
---
title: 'Projet - ACP sur des Eaux '
author: "Solène Catella, Hugo Le Baher"
date: "23 novembre 2018"
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


##Sommaire

[Introduction]

[1. Analyse univariée et bivariée]

[1.1 Etude du jeu de données]

[1.2 Analyse exloratoire des données]

[1.2.1 Recherche des données manquantes]

[1.2.2 Analyse unidimensionnelle : variables qualitatives]

[1.2.3 Analyse unidimensionnelle : variables quantitatives]

[1.2.4 Recherche des valeurs extrêmes/outliers]

[1.2.5 Analyse bidimensionnelle]

[2. Analyse multivariée]

[2.1 ACP sur le premier jeu de données]

[2.1.1 Sélection des axes et plans retenus]

[2.1.2 Projection des variables et observations dans un plan donné]

[2.1.3 Analyse des observations supplémentaires]

[2.2 ACP sur le deuxième jeu de données]

[2.4 Classification non supervisée de type k-means]

## Introduction

<div style="text-align:justify">
Gazeuse, dé-ionisée ou encore riche en magnésium, l'eau, élément naturel et central dans notre vie quotidienne, peut revêtir plusieurs formes. Sa composition minérale, sa provenance, sa nature mais aussi son potentiel hydrogène sont autant de paramètres qui entrent en jeu dans sa caractérisation. Analyser une eau revient donc à s'intéresser à l'ensemble des paramètres et propriétés susceptibles de la définir.

Le jeu de données dont nous disposons recense près de 80 eaux (83 exactement), déclinées sous 12 variables à la fois qualitatives (nom, nature, pays) et quantitatives (composition ionique, sodique, etc.). L'intérêt d'une ACP est, entre autres, de caractériser des observations dites "multivariées", c'est-à-dire multidimensionnelles, et d'en dégager des relations de ressemblance/dissemblance. En d'autres termes, l'ACP permet d'avoir une vue globale et synthétique des données : c'est la raison pour laquelle son usage est ici parfaitement approprié. 

Avant de procéder à l'ACP en tant que telle, nous explorerons le jeu de données au travers d'analyses univariées et bivariées. Une classification de type non-supervisée sera menée en dernier lieu, via la méthode des K-means.
</div>

## 1. Analyse univariée et bivariée
###1.1 Etude du jeu de données

`r waters <- read.table("./Eaux2018 FM.txt", header=TRUE, sep="\t")`

La commande `head` nous donne un premier aperçu du jeu de données étudié. Il s'agit de données relatives aux caractéristiques et propriétés minérales de diverses eaux.
```{r}
head(waters)
```

```{r}
dim(waters)
```
<div style="text-align:justify">
Le jeu de données comprend 95 observations réparties sur 12 variables, dont 3 catégorielles (Nom, Nature, Pays) et 9 numériques (Ca, Mg, Na, K, Cl NO3, SO4, HCO3, PH).

Dans ce jeu de données, on distingue 84 observations actives (eaux françaises) pour 11 observations supplémentaires (eaux marocaines).

On note que certaines données sont incomplètes. En effet, toutes les variables ne sont pas renseignées pour chacune des différentes eaux. Par exemple, les concentrations en K, Cl et SO4 de l'eau <em>Aquarelle</em>, ainsi que son PH, ne sont pas connus (cf. tableau). Il convient dans un premier temps d'étudier la fiabilité des différentes variables, de façon à détecter les valeurs manquantes, incohérentes, extrêmes ou aberrantes : c’est l’objet des résumés unidimensionnels. 
</div>

### 1.2 Analyse exloratoire des données
####1.2.1 Recherche des données manquantes

On s'intéresse dans un premier temps aux données manquantes, représentées via le symbole <em>NA</em>.

```{r}
colSums(is.na(waters))
```

<div style="text-align:justify">
Parmi les variables étudiées, on remarque que le NO3 et le PH sont celles qui enregistrent le plus grand nombre de valeurs manquantes (19 chacune), suivies des variables Cl, K, Nature, SO4 et HCO3. Ces données manquantes peuvent alors être : <br>

* Supprimées, de façon à ne conserver que les observations complètes ;
* Imputées par une valeur plausible ou aléatoire (méthodes d’imputation simples et multiples).

L’étude statistique unidimensionnelle peut nous aider à mieux appréhender la distribution des différentes variables, et préférer l’une ou l’autre de ces méthodes. Dans la mesure où l’Analyse en Composantes Principales (ACP) est une méthode appliquée à des variables quantitatives continues, nous nous intéresserons particulièrement à ces dernières, après avoir brièvement analyser les variables qualitatives.
</div>  
  
####1.2.2 Analyse unidimensionnelle : variables qualitatives

Le jeu de données comprend 3 variables qualitatives : le nom de l'eau (Nom), sa nature (Nature) et son origine (Pays).

```{r echo=FALSE}
cat.variables <- waters[sapply(waters, is.factor)]
```

Il peut ici être intéressant de s'intéresser aux propriétés minérales des eaux plates et gazeuses.

```{r echo=FALSE}
still.waters <- subset(waters, waters$Nature=='plat', select=Ca:PH)
gaz.waters <- subset(waters[sapply(waters, is.numeric)], waters$Nature=='gaz')
```
```{r}
summary(still.waters)
summary(gaz.waters)
```

<div style="text-align:justify">
Ces résumés nous indiquent que les eaux gazeuses sont en moyenne plus riches que les eaux plates tous minéraux confondus, à l'exception des nitrates (NO3) et sulfates (SO4). Les composants minéraux qui semblent être les plus discriminants dans la distinction des eaux plates et gazeuses sont le HCO3 et le Na (comparaison des médianes). On note également que les eaux gazeuses enregistrent un PH légèrement inférieur aux eaux plates. 

Il peut aussi être pertinent de s'intéresser à la répartition des eaux plates et gazeuses en France et au Maroc. Le diagramme en mosaïque (mosaic plot) permet de visualiser les effectifs relatifs à un tableau de contingence, ici donné par les variables Pays et Nature. 

```{r fig.align='center'}
table(waters$Nature, waters$Pays) 
mosaicplot(~waters$Pays+waters$Nature, data=waters, main="Répartition des eaux par Nature et Pays", color=TRUE)
```
On remarque que les eaux plates sont en quantité supérieure, représentant à peu près 2/3 du jeu de données. Les eaux gazeuses sont exclusivement françaises : il n'y a pas d'eaux marocaines gazeuses. On peut aussi relever que les eaux marocaines sont très peu représentées vis-à-vis des eaux françaises, raison pour laquelle elles sont sans doute traitées dans cette analyse comme des observations supplémentaires.<br/>
</div>

####1.2.3 Analyse unidimensionnelle : variables quantitatives

<div style="text-align:justify">
Nous nous intéressons désormais aux variables quantitatives.
 
La commande `summary` fournit un résumé détaillé des variables étudiées, ici numériques (minimum, premier quartile, médiane, moyenne, troisième quartile et maximum).
```{r}
summary(waters[sapply(waters, is.numeric)])
```

En moyenne, les eaux sont principalement concentrées en HCO3 (691.4 mg/L), Na (151.4 mg/L), Ca (111.1 mg/L) et SO4 (108.7 mg/L). Cependant, dans la mesure où un grand nombre de variables enregistrent des valeurs extrêmes telles HCO3 (maximum à 6722.2 mg/L) ou Na (maximum à 1945 mg/L), la médiane apparaît ici comme une meilleure mesure centrale, car plus robuste que la moyenne. Exception faites des variables HCO3 et Ca, on remarque que les concentrations oscillent alors entre 2 mg/L et 18 mg/L, tous composants minéraux confondus.
</div>

```{r echo=FALSE, fig.align='center'}
boxplot(waters[sapply(waters, is.numeric)])
```

<div style="text-align:justify">
Un examen plus fin, variable par variable, nous permettra de mieux apprécier leurs distributions respectives. On s’intéressera principalement aux variables PH et NO3, qui enregistrent ici le plus grand nombre de données manquantes (19).
</div>

##### <br/><u>Etude de la variable PH</u>

<div style="text-align:justify">
Le tracé de la boîte à moustache de la variable PH laisse apparaître une distribution symétrique. On note que les valeurs de sa moyenne (6.905) et sa médiane (7.000) sont très proches. Sa distribution, homogène et faiblement dispersée, semble s’approcher de celle d’une loi Normale (voire figure ci-contre).
</div>

```{r echo=FALSE, fig.width=5, fig.height=5, fig.show='hold', out.width="49%"}
boxplot(waters$PH, main="Boîte à moustache de la variable PH")
hist(waters$PH, prob=TRUE, main="Histogramme et densité de probabilité du PH", xlab="PH")
curve(dnorm(x, mean=mean(waters$PH, na.rm=TRUE), sd=sd(waters$PH, na.rm=TRUE)), add=TRUE, col="red")
```

<div style="text-align:justify">
L'histogramme du PH, approché par une courbe de densité en forme de "cloche", vient confirmer cette hypothèse (voir figure ci-contre).
</div>

##### <br/><u>Etude de la variable NO3</u>

La distribution de la variable NO3 est ici quelque peu différente : l’histogramme indique une distribution non-symétrique et non-homogène.

```{r echo=FALSE, fig.width=5, fig.height=5, fig.show='hold', out.width="49%"}
boxplot(waters$NO3, main="Boîte à moustache de la variable NO3")
hist(waters$NO3, prob=TRUE, main="Histogramme et densité de probabilité du NO3", xlab="NO3")
curve(dnorm(x, mean=mean(waters$NO3, na.rm=TRUE), sd=sd(waters$NO3, na.rm=TRUE)), add=TRUE, col="red")
```

<div style="text-align:justify">
Le tracé de la boîte à moustache de cette variable révèle la présence de nombreuses valeurs extrêmes (symbolisées par un “°”) : ces valeurs s'écartent fortement de la valeur moyenne obtenue. 
</div>

##### <br/><u>Etude des variables Cl, K, SO4 et HCO3 :</u>

<div style="text-align:justify">
Les variables Cl, K, SO4 et HCO3 témoignent d’une distribution à nouveau non symétrique, peu homogène, enregistrant un grand nombre de valeurs extrêmes. Le tracé de leur densité de probabilité s’éloigne ici d’une loi normale. 

```{r echo=FALSE, fig.height=8, fig.width=10, out.width="100%", fig.align='center'}
par(mfrow=c(2,2))
hist(waters$Cl, prob=TRUE, main="Histogramme et densité de probabilité du Cl", xlab="Cl")
curve(dnorm(x, mean=mean(waters$Cl, na.rm=TRUE), sd=sd(waters$Cl, na.rm=TRUE)), add=TRUE, col="red")
hist(waters$K, prob=TRUE, main="Histogramme et densité de probabilité du K", xlab="K")
curve(dnorm(x, mean=mean(waters$K, na.rm=TRUE), sd=sd(waters$K, na.rm=TRUE)), add=TRUE, col="red")
hist(waters$SO4, prob=TRUE, main="Histogramme et densité de probabilité du SO4", xlab="SO4")
curve(dnorm(x, mean=mean(waters$SO4, na.rm=TRUE), sd=sd(waters$SO4, na.rm=TRUE)), add=TRUE, col="red")
hist(waters$HCO3, prob=TRUE, main="Histogramme et densité de probabilité du HCO3", xlab="HCO3")
curve(dnorm(x, mean=mean(waters$HCO3, na.rm=TRUE), sd=sd(waters$HCO3, na.rm=TRUE)), add=TRUE, col="red")
```

<br/>Avant de poursuivre notre analyse par une étude bidimensionnelle, il peut donc être pertinent de s’intéresser aux données suspectes (outliers) susceptibles d’être à l’origine de ces distorsions, afin de les corriger et/ou supprimer puisqu’elles influeront nécessairement sur les résultats obtenus en ACP.
</div>


####1.2.4 Recherche des valeurs extrêmes/outliers

<div style="text-align:justify">
Le repérage des données suspectes peut être mené via plusieurs méthodes. Le test de Grubbs est le test le plus courant, mais n’étant applicable que si la distribution de l’échantillon est Normale ou voisine de la Normale, il ne sera ici pas retenu.

Graphiquement, le tracé des boxplots révèle la présence d’outliers pour les variables SO4, K, Na, Cl et HCO3, et dans une moindre mesure NO3, Ca et Mg. Dans le cadre de variables continues, il s’agit des observations dont la valeur excède 1.5 fois l’écart interquartile. La commande `boxplot.stats(data)$out` permet de dégager ces valeurs, en considérant chaque variable prise une à une (par exemple ici, SO4) :

</div>

```{r}
boxplot.stats(waters$SO4)$out
```

La commande which permet d’identifier les indices des outliers :

```{r}
which(waters$SO4 %in% boxplot.stats(waters$SO4)$out)
```
  
<div style="text-align:justify">
Les outliers sont donc très présents dans ce jeu de données. Il pourrait ainsi être judicieux de générer un deuxième jeu de données sans ces extrema, ou en tout cas essayer de s'en affranchir autant que faire se peut, de façon à ne pas biaiser la suite de notre étude. Passer ces données en observations supplémentaires dans le cadre de notre ACP est une façon de neutraliser ces valeurs.
</div>

 
####1.2.5 Analyse bidimensionnelle

<div style="text-align:justify">
Intéressons-nous désormais à l'analyse bidimensionnelle. L’objectif ici est de pouvoir mettre en évidence, pour chaque paire de variables considérée, l’existence de variations simultanées, aussi appelées liaisons. 
La matrice des scatterplots permet de visualiser les liaisons existantes entre variables quantitatives prises deux à deux. 
</div>

```{r, fig.align='center'}
plot(waters[sapply(waters, is.numeric)])
```

<div style="text-align:justify">
On observe ainsi graphiquement l’existence de corrélations entre les variables Na, K et HCO3. Cette hypothèse peut être vérifiée via l’étude numérique des corrélations inter-variables (`commande cor`).
</div>

```{r, fig.align='center'}
round(cor(waters[sapply(waters, is.numeric)], use="complete.obs"),3)
```

<div style="text-align:justify">

Les variables les plus corrélées positivement sont les variables HCO3 et NA (0.910), Na et K (0.867) et HCO3 et K (0.883) : elles varient simultanément de façon semblable.  
  
On remarque que le PH est corrélé négativement à toutes les autres variables, exception faite du composant S04. Le comportement de cette variable est donc, de façon générale, opposé à celui des autres variables.  
  
Il faut cependant rester vigilant quant aux résultats obtenus. En effet, la présence de valeurs extrêmes peut venir perturber notre analyse, ici portée sur l’étude des corrélations. En effet, le coefficient de corrélation de Pearson (méthode par défaut) est très sensible aux valeurs de données extrêmes. Il peut donc être intéressant de réitérer cette analyse sans prendre en compte cette fois-ci les données extrêmes/outliers enregistrés, soit en les supprimant, soit en transformant les variables pour rendre plus symétriques et moins étalées certaines distributions (en prenant les logarithmes par exemple). Nous mettrons en oeuvre ici la première option :

```{r echo=FALSE}
library(plotrix)
library(ade4)

acpn = function(data_in, round_precision = 3){  
  result = list()
  
  result$source = data_in
  #Filtre
  result$raw_data = na.omit(data_in[sapply(data_in, is.numeric)])
  result$matrix = as.matrix(result$raw_data, rownames.force = NA)
  
  #Retour
  return(result)
}
waters <- read.table("./Eaux2018 FM.txt", header=TRUE, sep="\t")
active.waters <- waters[waters$Pays %in% "France",] 
supp.waters <- waters[waters$Pays %in% "Maroc",] 
acp_waters = acpn(active.waters)
round(cor(acp_waters$matrix[setdiff(c(1:nrow(acp_waters$matrix)), unique(unlist(apply(acp_waters$matrix, 2, function(x){which(x %in% boxplot.stats(x)$out)})))),]),3)
```

L'élimination des outliers du jeu de données laisse apparaître de nouvelles corrélations, en particulier au niveau de la variable HCO3, désormais très corrélée aux variables Mg, Na et SO4 - elles-mêmes très corrélées entre elles. Il pourra donc être intéressant d'étudier ce groupe de variables dans le cadre de notre troisième ACP, où nous passerons les différents extrema recensés en observations supplémentaires. L'idée sera alors de comparer, d'une ACP à l'autre, les groupes de variables formés et la nature des axes en découlant. 
</div>

##2. Analyse multivariée

<div style="text-align:justify">
Deux jeux de données seront ici considérés :

* un premier jeu de données diminué des données manquantes (approche simpliste) ;
* un deuxième jeu de données où l’ensemble des données manquantes seront substituées par des valeurs approximatives, et ce afin de conserver le maximum d’information possible.

Il s’agira donc de travailler sur les données brutes d’abord (1), puis sur un jeu de données transformé ensuite (2). Dans la mesure où les résultats d’une ACP peuvent être biaisés par la présence de données suspectes et que celles-ci sont ici nombreuses, une troisième ACP, où seront passés en individus supplémentaires l’ensemble des données suspectes, sera réalisée. À noter qu’il aurait également été envisageable de neutraliser ces données à l’aide d’une ACP sur les rangs, plus robuste qu’une ACP classique.
</div>

###2.1 ACP sur le premier jeu de données

<div style="text-align:justify">
Nous considérons ici le jeu de données brutes, diminué des données manquantes. <br/>
La commande na.omit permet d’éliminer d’un jeu de données toutes les lignes incomplètes (contenant des valeurs “NA”).

```{r}
complete.waters <- na.omit(waters)
dim(complete.waters)
```

On note que 33 observations ont ainsi été retirés du jeu de données initial.

De plus, dans la mesure où l’on souhaite ici que les eaux marocaines soient traitées comme des observations supplémentaires et non pas actives, il faut veiller à les retirer au préalable. Une fois ce traitement réalisé, le jeu de données à traiter ne comporte alors plus que 55 lignes.

Avant de débuter l’ACP à proprement parler, il convient de faire un choix de métrique. Dans la mesure où la variable PH ne s’exprime pas dans la même unité que les autres variables (concentrations en mg/L), on préfèrera ici mettre en oeuvre une ACP normée (ACPN). Éliminer la variable PH du jeu de données conduirait en effet à une perte d’information non négligeable. De plus, les variances des variables étant très éloignées les unes des autres, une ACP non normée n'apparait pas judicieuse.<br/>
</div>

####2.1.1 Sélection des axes et plans retenus

L’ACPN est effectué par un appel à la procédure `dudi.pca`.

La première étape consiste à sélectionner les axes à retenir. Cette sélection s’appuie sur l’examen des valeurs propres, où chaque valeur propre correspond à la part d’inertie projetée sur un axe donnée.

```{r echo=FALSE}
active.waters <- complete.waters[complete.waters$Pays %in% "France",] 
acp.variables <- active.waters[sapply(active.waters, is.numeric)] # On ne conserve que les obs. actives
library(ade4)
auto.acp <- dudi.pca(df = acp.variables, center = TRUE, scale = TRUE, scannf = FALSE, nf = 9)
```

<div style="text-align:justify">
Dans le cadre d’une ACP normée, on peut utiliser le critère de Kaiser selon lequel ne seront retenus que les facteurs ayant une valeur propre supérieure à 1. On remarque ici que seules les trois premières valeurs propres sont supérieures à 1. L’histogramme des valeurs propres traduit ce fait.
</div>

```{r}
round(cumsum(100*auto.acp$eig/sum(auto.acp$eig)), 3)
```
Cumulées, elles représentent alors plus de 82.02% de la variabilité totale. On ne conservera donc ici que les trois premiers axes.
<br/>  

####2.1.2 Projection des variables et observations dans un plan donné
  
#####<u>Analyse des variables</u>

```{r}
round(auto.acp$co,3)
```

<div style="text-align:justify">
On remarque que :

* La première composante traduit l’existence de fortes corrélations entre HCO3 (-0.917), K (-0.907), Na (-0.864) et Mg (-0.792), comme évoqué un peu plus haut.
* La deuxième composante traduit l’existence de fortes corrélations entre Ca (-0.886) et SO4 (-0.944).
* Enfin, la troisième composante traduit l’existence de corrélations négatives entre NO3 (-0.903) et PH (0.554)

NB : On note que la variabilité des six dernières composantes principales est beaucoup plus faible que celle des composantes retenues. Autrement dit, la distance qu’elles traduisent entre les observations est négligeable.<br/>

Le tracé du cercle des corrélations peut nous aider à apprécier ces corrélations, ainsi que la bonne représentation des différentes variables. Dans la mesure où l’on a décidé ici de retenir 3 axes, il faut alors tracer trois graphiques distincts pour chaque nuage : le nuage projeté sur le plan (axe1, axe2), celui projeté sur le plan (axe1, axe3) et enfin celui sur le plan (axe2, axe3).  
</div>

```{r echo=FALSE, out.width='49%'}
s.corcircle(auto.acp$co, xax=1, yax=2); mtext("Cercle des corrélations dans le plan 1-2")
s.corcircle(auto.acp$co, xax=1, yax=3); mtext("Cercle des corrélations dans le plan 1-3")
s.corcircle(auto.acp$co, xax=2, yax=3); mtext("Cercle des corrélations dans le plan 2-3")
```

<div style="text-align:justify">
Le premier plan principal permet de distinguer 2 groupes de variables distincts, tels que décrits plus haut : Na, K, HCO3 et Cl d’une part, Mg, Ca et SO4 d’autre part. Les variables NO3 et PH sont assez mal représentées dans ce plan (éloignées du bord du cercle de corrélation), à la différence des plans 1-3 et 2-3 où leur représentation est bonne. L’existence de corrélations négatives entre ces deux variables est facilement visualisable dans ces configurations. La conservation des trois premiers axes est donc ici nécessaire si l’on ne souhaite pas aboutir à de mauvaises interprétations.

<u>Interprétation des axes :</u>

* Axe 1 : cet axe est lié aux concentrations en Na, K, Cl et HCO3. Il caractérise la teneur sodique des eaux (riches en sodium ou non) ;
* Axe 2 : cet axe est lié aux concentrations en Ca, Mg et SO4. Il caractérise la teneur minérale des eaux (fortement minéralisées ou non) ;
* Axe 3 : cet axe est lié aux concentrations en NO3. Il caractérise le pouvoir nitrique des eaux (acides ou non).

L'analyse des répartition des observations par nature (eaux plates ou gazeuses) dans chacun des plans permettra de mettre en confrontation les variables quantitatives ici présentées avec la variable qualitative Nature (voir plus bas).
</div>

##### <br/><u>Analyse des observations</u>
<div style="text-align:justify">

```{r echo=FALSE}
obs.inertie <- inertia.dudi(auto.acp, row.inertia=TRUE)
obs.ctr <- obs.inertie$row.abs/100 # (Contribution des observations en %)
obs.qlt <- obs.inertie$row.re/100 # (Qualité des observations en %)
```

<u>Qualité de représentation des observations :</u>

La commande `obs.inertie$row.re/100` permet d’apprécier la qualité de représentation des différents individus sur les différents axes.
La qualité de représentation d’un individu dans un plan donné s’évalue en sommant les qualités de représentation de ce même individu sur les axes du plan donné. Sont affichées ici les 30 premières qualités. 

NB : Il faut se reporter au jeu de données initial pour établir la correspondance entre un échantillon (numéro) et le nom de l'eau qui y est associé.

```{r}
head(round(obs.qlt[,1:3],3),30)
```

<B>Plan 1-2 :</B>
les individus les mieux représentés dans le plan 1-2 sont les eaux Contrex (99,06%), Hepar (98,82%), Courmayeur (95,46%), Talians (95,32%), Christalline Aurelie (92,61%), Zilia (92,14%) et Arvie (90,36%). Les individus les moins bien représentés dans le plan 1-2 sont les eaux Perrier (1,97%), Salvetat (2,55%) et Christalline St Sophie (6,99%)

<B>Plan 1-3 : </B>
les individus les mieux représentés dans le plan 1-3 sont les eaux Perrier (94,54%), Montagne Ecrins (92,38%), Montagne Alpes (92,37%) et Christalline Aurelie  (92,11%). Les individus les moins bien représentés dans le plan 1-3 sont les eaux Contrex (0,88%), Courmayeur (1,23%), Talians (2,45%), Hepar (2,60%) et Salvetat (5,92%)

<B>Plan 2-3 :</B>
les individus les mieux représentés dans le plan 2-3 sont les eaux Contrex (98,18%), Courmayeur (96,65%), Talians (96,51%), 44 (96,22%) et Perrier (92,85%). Les individus les moins bien représentés dans le plan 2-3 sont les eaux Rozana (1,31%), Chateldon (3,36%), Christalline Aurelie (4,24%), Christalline St JB (4,86%) et Arvie (6,66%)

<u>Contribution des observations aux axes :</u>

Nous nous intéressons ici aux observations dont la contribution est supérieure à la contribution moyenne par axe.
Voici un extrait des contributions des observations aux axes 1, 2 et 3.

```{r}
head(round(obs.ctr[,1:3],3),40)
```

Les eaux Arvie (échantillon 10), Rozana (échantillon 63), Parot (échantillon 57) et Vichy Celestins (échantillon 78) enregistrent les valeurs (absolues) de la première composante les plus élevées. Ces eaux sont naturellement riches en Na, K, Cl et HCO3, plutôt acides (PH < 7) et gazeuses.<br/>

Un examen identique de la seconde composante révèle que les eaux Talians (échantillon 72), Hepar (échantillon 44), Courmayeur (échantillon 20) et Contrex (échantillon 19) ont des valeurs très supérieures à la moyenne sur cette composante. Ces eaux sont naturellement riches en Ca, Mg et SO4, plutôt basiques ou alcalines (PH > 7) et plates.<br/>

Enfin, les eaux Perrier (échantillon 58), Thonon (échantillon 74), Ste Marguerite (échantillon 68) et Badoit (échantillon 12) enregistrent les valeurs les plus élevées de la troisième composante. Ces eaux ont la particularité d’être fortement concentrées en NO3.<br/>

L’ACP a donc permis de mettre en évidence des groupements de propriétés minérales propres à certains types d’eaux, difficilement perceptible au premier coup d’oeil.<br/>

En résumé, la contribution des individus aux différents axes (par ordre décroissant de contribution) est la suivante :

Axe 1 : Arvie, Rozana, Parot, Vichy Celestins
 
Axe 2 : Talians, Hepar, Courmayeur, Contrex
 
Axe 3 :  Perrier, Thonon, Ste Marguerite, Badoit

##### <br/><u>Analyse croisée des variables et observations</u>

Le tracé des graphiques de répartion des eaux par Nature (plates, gazeuses) dans les différents plans considérés est présenté ci contre. Il permet notamment de mettre en relation les variables quantitatives précédemment étudiées avec la variable qualitative Nature, en considérant les individus bien représentés seulement. 

En rouge, sont désignées les observations de nature gazeuse; en noir, les observations de nature plate. 
Les cercles de corrélations ici dessinés sont ceux issus de notre fonction ACP.

```{r echo=FALSE, out.width='49%'}
acpn = function(data_in, round_precision = 3){  
  result = list()
  
  result$source = data_in
  #Filtre
  result$raw_data = na.omit(data_in[sapply(data_in, is.numeric)])
  result$matrix = as.matrix(result$raw_data, rownames.force = NA)
  num_row = nrow(result$raw_data)
  num_col = ncol(result$raw_data)
  
  #Moyenne
  result$mean = apply(result$matrix, 2, mean)
  result$meanmatrix = t(matrix( rep(x=result$mean, num_row), nrow = num_col, byrow = FALSE))

  #Centrage avec scale
  result$autocen = scale(result$matrix, center = TRUE, scale = FALSE)
  #Centrage/Reduction avec scale
  result$autocenred = scale(result$matrix, center = TRUE, scale = TRUE)

  #Centrage sans scale
  result$cen = result$matrix - result$meanmatrix

  #Variance/co-variance
  result$var = t(result$cen) %*% result$cen / (num_row - 1)
    
  #Centrage/Reduction sans scale
  result$stddev = diag(sapply(diag(as.matrix(result$var)), function(x){1/sqrt(x)}))
  result$cenred = result$cen %*% result$stddev
  
  #Correlation
  result$cor = t(result$cenred) %*% result$cenred / (num_row - 1)
  
  #Valeurs propres
  eigen_full = eigen(result$cor)
  result$eigen$values = eigen_full$values[eigen_full$values>1.0]
  result$eigen$vectors = eigen_full$vectors[,1:length(result$eigen$values)]
  
  #Composantes principales
  result$comp = result$cenred %*% result$eigen$vectors
  
  #Rapport de l'inertie
  result$inertiaratio = result$eigen$values / num_col
  
  #Inertie cumulée
  result$inertiasum = round(sum(result$inertiaratio),3)*100

  #Contribution relative des individus
  result$qlti = (result$comp)^2
  for (i in 1:nrow(result$qlti)) {
    for (k in 1:ncol(result$qlti)) {
      result$qlti[i,k] = result$qlti[i,k] / (sum(result$comp[i,]^2))
    }
  }
  result$qtli = round(result$qlti, round_precision)
  
  #Contribution absolue des individus
  result$ctri = (result$comp)^2
  for (i in 1:nrow(result$ctri)) {
    for (k in 1:ncol(result$ctri)) {
      result$ctri[i,k] = result$ctri[i,k] / (ncol(result$ctri)*result$eigen$values[k])
    }
  }
  result$ctri = round(result$ctri, round_precision)
  
  #Matrice des coordonnées de variables
  D = diag(sapply(as.matrix(result$eigen$values), sqrt))
  result$coords = result$eigen$vectors %*% D
  
  #Contribution relative des variables
  result$qltv = (result$coords)^2
  for (j in 1:nrow(result$qltv)) {
    for (k in 1:ncol(result$qltv)) {
      result$qltv[j,k] = result$qltv[j,k] / (sum(result$coords[j,]^2))
    }
  }
  result$qtlv = round(result$qltv, round_precision)
  
  #Contribution absolue des variables
  result$ctri = (result$comp)^2
  for (i in 1:nrow(result$ctri)) {
    for (k in 1:ncol(result$ctri)) {
      result$ctri[i,k] = result$ctri[i,k] / (ncol(result$ctri)*result$eigen$values[k])
    }
  }
  result$ctri = round(result$ctri, round_precision)
  
  #Cercle de corrélation
  apply(combn(1:length(result$eigen$values), 2), 2, function(combi){
    axis1 = result$coords[,combi[1]]
    axis2 = result$coords[,combi[2]]
    par(mfrow=c(1,1))
    plot(axis1, axis2, xlim=c(-1,1), ylim=c(-1,1), asp = 1, type = "n", xlab = sprintf("Axe %d",combi[1]), ylab = sprintf("Axe %d",combi[2]), main = sprintf("Cercle des corrélations dans le plan %d-%d", combi[1], combi[2]) )
    abline(h=0,v=0)
    draw.circle(x = 0, y = 0, radius = c(1,1))
    arrows(0, 0, axis1, axis2, length = 0.10, code = 2, col = gray(0.6))
    text(x=axis1, y=axis2, labels = colnames(result$raw_data), font=2) 
  })
  
  #Retour
  return(result)
}

waters <- read.table("./Eaux2018 FM.txt", header=TRUE, sep="\t")
active.waters <- waters[waters$Pays %in% "France",] 
supp.waters <- waters[waters$Pays %in% "Maroc",] 
acp_waters = acpn(active.waters)

water_type = c()
for(i in rownames(acp_waters$comp)){
  type = acp_waters$source$Nature[strtoi(i)]
  v = 0
  if(is.na(type)){}
  else if(type == "plat"){
    v=1
  }else if(type == "gaz"){
    v=2
  }
  water_type = c(water_type, v)
}

plot(main="Répartition des eaux par nature dans le plan 1-2", acp_waters$comp[,1], acp_waters$comp[,2], xlab = "Axe 1", ylab = "Axe 2", col=water_type)
legend(x = "bottomright",legend=unique(water_type),col=1:length(water_type),pch=1)

plot(main="Répartition des eaux par nature dans le plan 1-3", acp_waters$comp[,1], acp_waters$comp[,3], xlab = "Axe 1", ylab = "Axe 3", col=water_type)
legend(x = "bottomright",legend=unique(water_type),col=1:length(water_type),pch=1)

plot(main="Répartition des eaux par nature dans le plan 2-3", acp_waters$comp[,1], acp_waters$comp[,3], xlab = "Axe 2", ylab = "Axe 3", col=water_type)
legend(x = "bottomright",legend=unique(water_type),col=1:length(water_type),pch=1)

```

On remarque que c'est dans le plan 1-2 que la séparation entre eaux plates et gazeuses est la meilleure. Or, nous avons précédemment déduit que l'axe 1 était associé aux concentrations en Na, K, Cl et HCO3 d'une part, et que les composants minéraux qui semblaient être les plus discriminants dans la distinction des eaux plates et gazeuses étaient le HCO3 et le Na d'autre part. L'analyse est donc concordante avec le graphique, et les résultats de notre ACP.

</div><br/>

####2.1.3 Analyse des observations supplémentaires
```{r echo=FALSE}
supp.waters <- waters[waters$Pays %in% "Maroc",] 
supp.waters
summary(supp.waters)
```

<div style="text-align:justify">
Les observations supplémentaires sont des eaux provenant du Maroc, exclusivement plates. Comparativement aux eaux françaises, les eaux marocaines sont beaucoup plus riches en Na.

Parmi ces 11 observations supplémentaires, 4 enregistrent des valeurs manquantes, notamment au niveau de leur PH. Dans la mesure où nous avons précédemment vu que la distribution du PH s’apparente à celle d’une loi normale, on peut raisonnablement substituer ces valeurs manquantes par la valeur médiane de cette variable, qui vaut ici 7.0. Cela évite ainsi d’éliminer un tiers des observations supplémentaires.<br/>

Etant donné que nous n’avons pas réalisé d’estimation pour les données manquantes enregistrées au niveau de la variable Cl (cf. deuxième jeu de données), nous avons ici pris le parti de supprimer l’observation Ain Soltane (échantillon 89).
Ces individus supplémentaires (ici en rouge) ont été représentés dans chacun des plans 1-2, 1-3 et 2-3 :
</div>

```{r echo=FALSE}
new.supp.waters <- na.omit(supp.waters)
cl1 <- auto.acp$li[,1]
cl2 <- auto.acp$li[,2]
cl3 <- auto.acp$li[,3]
ligsup <- suprow(auto.acp,new.supp.waters[3:11])
csup1 <- ligsup$lisup[,1]
csup2 <- ligsup$lisup[,2]
```

```{r echo=FALSE, out.width="49%"}
plot(cl1, cl2, type="n", main="Individus actifs et supplémentaires dans le plan 1-2", xlim=c(-2,2))
abline(h=0,v=0)
text(cl1, cl2, row.names(auto.acp$li),)
text(csup1, csup2, row.names(ligsup$lisup), col="red", cex=1.2)
# Graphe des observations actives et supplémentaires - plan 1-3
csup3 <- ligsup$lisup[,3]
plot(cl1, cl3, type="n", main="Individus actifs et supplémentaires dans le plan 1-3", xlim=c(-2,2))
abline(h=0,v=0)
text(cl1, cl3, row.names(auto.acp$li),)
text(csup1, csup3, row.names(ligsup$lisup), col="red", cex=1.2)
# Graphe des observations actives et supplémentaires - plan 2-3
plot(cl2, cl3, type="n", main="Individus actifs et supplémentaires dans le plan 2-3", xlim=c(-2,2))
abline(h=0,v=0)
text(cl2, cl3, row.names(auto.acp$li),)
text(csup2, csup3, row.names(ligsup$lisup), col="red", cex=1.2)
```

<U>Interprétation :</U>



##2.2 ACP sur le deuxième jeu de données

<div style="text-align:justify">
Nous considérons ici un deuxième jeu de données où les valeurs manquantes ne sont plus supprimées mais substituées/imputées par des valeurs approximatives.

Pour ce faire, on peut utiliser l’algorithme des k plus proches voisins, déjà implémenté au sein du package DMwR. Pour chaque valeur manquante, l’algorithme identifie les k observations les plus proches en terme de distance euclidienne et en calcule la moyenne pondérée.

La fonction `knnImputation` permet de générer un nouveau jeu de données suivant cette méthode. En voici un aperçu :

```{r echo=FALSE}
library(DMwR)
new.waters <- knnImputation(waters, k=10, scale=T, meth="weighAvg", distData=NULL) # On fixe k à 10 voisins
new.active.waters <- new.waters[new.waters$Pays %in% "France",]
head(new.active.waters)
```

On remarque par exemple que l'eau <em>Aquarelle</em>, originellement incomplète, a ici été imputée au niveau des variables K, Cl, SO4 et PH par les valeurs 1.01, 7.19, 20.67 et 7.12.

Nous pouvons désormais appliquer notre ACP sur ce nouveau jeu de données.

</div>

<<<<<<< HEAD
##2.4 Classification non supervisée de type k-means
=======
##<br/>2.4. Classification non supervisée de type k-means

Pour approfondir notre analyse, on peut choisir de classer nos individus par catégories, par classes. Ainsi, on pourrait voir apparaître différents types d'eau dans nos données.  
  
Plusieurs méthodes s'offrent à nous. Cependant, nous n'avons pas vraiment de types d'eaux prédéfinis, ni de données d'entrainement sur lesquelles on pourrait s'appuyer. Le choix d'une méthode de partitionnement non supervisé semble donc raisonnable.  
  
La fonction kmeans(data, k) déjà implémentée remplit ce rôle de manière satisfasante. À partir des données d'entrée et d'un nombre de classes k, l'algorithme va alors regrouper les individus selon les distances des uns par rapport aux autres, jusqu'à trouver les distances minimales.
  
Même si l'algorithme est déjà implémenté, il nous faut quand même trouver un k optimal. En effet ce choix est primordial. Si on prend un k trop petit on risque d'avoir des classes peu représentatives, assez arbitraires. Cependant si on prend un k trop grand, on peut avoir des classes qui ne s'appliquent qu'à notre jeu de données ou alors avoir beaucoup de classes mais avec très peu d'individus.  
  
Un nombre classique de classes est $\sqrt{2/n}$, notre n étant le nombre d'individus c'est à dire 63 après avoir filtré les données, un k optimal s'approcherait de 6. On va confirmer cette hypothèse avec la méthode suivante :  
  
Quand on applique l'algorithme, il nous renvoie la somme des carrées des distances entre les individus et le centre des classes. Une part plus petite par rapport à la somme de toutes les distances étant meilleure, on peut dessiner le graphique de cette part, en fonction de k. En observant les décrochages de la courbe, on peut alors décider d'un k satisfaisant.  
  
Il faut aussi préciser que la fonction kmeans incorpore de l'aléatoire, on préfère donc fixer la graine de l'aléatoire afin d'avoir toujours les mêmes résultats.

L'algorithme nous revoie donc un tableau des individus avec un numéros de classe associé. On peut donc, pour se donner une idée, appliquer ce tableau à une représentation en deux ou trois dimensions issue de l'ACP.
>>>>>>> eeac477994d5a8d3ca1b47a6743892a4a5f96938
